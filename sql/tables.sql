CREATE TYPE valorant_rank AS ENUM (
  'iron',
  'bronze',
  'silver',
  'gold',
  'platinum',
  'diamond',
  'ascendant',
  'immortal',
  'radiant'
);

create table
  public.rankdles (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    tracker_match uuid not null,
    youtube_id text not null,
    rank public.valorant_rank not null,
    val_id text null,
    constraint rankdles_pkey primary key (id),
    constraint rankdles_youtube_id_key unique (youtube_id)
  ) tablespace pg_default;

create index if not exists rankdles_created_at_idx on public.rankdles using btree (created_at) tablespace pg_default;

create table
  public.guesses (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    clip_id bigint not null,
    rank public.valorant_rank not null,
    user_id uuid null,
    constraint votes_pkey primary key (id),
    constraint guesses_clip_id_fkey foreign key (clip_id) references rankdles (id) on delete cascade,
    constraint guesses_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.daily_rankdles_log (
    id bigint generated by default as identity not null,
    rankdle_id bigint not null,
    shown_date date not null,
    constraint daily_rankdles_log_pkey primary key (id),
    constraint daily_rankdles_log_rankdle_id_key unique (rankdle_id),
    constraint unique_rankdle_id_shown_date unique (rankdle_id, shown_date),
    constraint daily_rankdles_log_rankdle_id_fkey foreign key (rankdle_id) references rankdles (id) on delete cascade
  ) tablespace pg_default;

create index if not exists daily_rankdles_log_shown_date_idx on public.daily_rankdles_log using btree (shown_date) tablespace pg_default;

create index if not exists daily_rankdles_log_rankdle_id_idx on public.daily_rankdles_log using btree (rankdle_id) tablespace pg_default;

create table
  public.proposed (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    tracker_id uuid not null,
    youtube_id text not null,
    val_id text not null,
    user_id uuid not null,
    constraint proposed_pkey primary key (id),
    constraint proposed_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

CREATE OR REPLACE FUNCTION public.get_daily_rankdles()
RETURNS TABLE (
  id bigint,
  created_at timestamp with time zone,
  tracker_match uuid,
  youtube_id text,
  rank public.valorant_rank,
  val_id text,
  log_id bigint
) AS $$
DECLARE
  cur_date_utc DATE := date_trunc('day', current_timestamp AT TIME ZONE 'UTC')::date;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM public.daily_rankdles_log
    WHERE shown_date = cur_date_utc
  ) THEN
    -- Insert new rankdles if there are no entries for the current date
    WITH new_rankdles AS (
      SELECT r.id AS rankdle_id
      FROM public.rankdles r
      WHERE r.created_at >= cur_date_utc - interval '30 day' AND
            r.created_at < cur_date_utc AND
            NOT EXISTS (
              SELECT 1
              FROM public.daily_rankdles_log l
              WHERE l.rankdle_id = r.id
            )
      ORDER BY r.created_at
      LIMIT 3
    )
    INSERT INTO public.daily_rankdles_log (rankdle_id, shown_date)
    SELECT rankdle_id, cur_date_utc FROM new_rankdles;
  END IF;

  -- Retrieve today's rankdles
  RETURN QUERY
  SELECT r.id, r.created_at, r.tracker_match, r.youtube_id, r.rank, r.val_id, l.id AS log_id
  FROM public.rankdles r
  JOIN public.daily_rankdles_log l ON r.id = l.rankdle_id
  WHERE l.shown_date = cur_date_utc;
END;
$$ LANGUAGE plpgsql
SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_rank_distribution(p_clip_id INTEGER)
RETURNS TABLE (
    rank_rankdle valorant_rank,
    percentage NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    WITH total_guesses_per_clip AS (
        SELECT
            clip_id,
            COUNT(*) AS total_count
        FROM
            guesses
        WHERE
            clip_id = p_clip_id
        GROUP BY
            clip_id
    )
    SELECT
        g.rank,
        (COUNT(*)::NUMERIC / tg.total_count::NUMERIC) * 100 AS percentage
    FROM
        guesses g
    JOIN
        total_guesses_per_clip tg
    ON
        g.clip_id = tg.clip_id
    WHERE
        g.clip_id = p_clip_id
    GROUP BY
        g.rank, tg.total_count
    ORDER BY
        g.rank;
END;
$$;

CREATE OR REPLACE FUNCTION delete_user()
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  DELETE FROM auth.users WHERE auth.users.id = auth.uid();
END;
$$;

select get_claim('ADMIN_AUTH_UUID', 'approver');

CREATE POLICY enable_insert_for_all_users
    ON public.guesses
    FOR INSERT
    WITH CHECK (true);

CREATE POLICY enable_delete_for_admin
    ON public.proposed
    FOR DELETE
    TO authenticated
    USING (auth.uid() = 'ADMIN_AUTH_UUID');

CREATE POLICY enable_insert_for_admin
    ON public.proposed
    FOR SELECT
    TO authenticated
    USING (auth.uid() = 'ADMIN_AUTH_UUID');

CREATE POLICY enable_insert_for_all_users
    ON public.proposed
    FOR INSERT
    TO authenticated
    WITH CHECK (true);
    
CREATE POLICY enable_insert_for_admin
    ON public.rankdles
    FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = 'ADMIN_AUTH_UUID');

CREATE POLICY enable_read_for_all_users
    ON public.rankdles
    FOR SELECT
    USING (true);

ALTER TABLE public.daily_rankdles_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.guesses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.proposed ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rankdles ENABLE ROW LEVEL SECURITY;

